## 아이템 1
### 생성자 대신 정적 팩터리 메서드를 고려하라
1. 클래스의 인스턴스를 얻는 정통적인 수단은 public 생성자. But, 클래스는 별도로 정적 팩터리 메서드를 제공할 수 있음.
1. 장점
    1. 이름을 가질 수 있다.
        1. 객체가 가지는 특성을 쉽게 묘사할 수 있다.
        ex.) BigInteger(int, int, Random), BigInteger.probabalePrime
        1. 시그니처가 같은 생성자를 여러 개 만드는데 제약이 없다.
        생성자를 정적 팩터리 메소드로 변경 후 각 차이를 잘 드러내도록 명명해주면 된다.
    1. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
        1. 불필요한 객체 생성을 피할 수 있다.
        Boolean.valueOf(boolean) 메서드는 객체를 아예 생성하지 않는다. ⇒ 성능을 끌어올려 준다.
    1. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
    1. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
        1. 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.
    1. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
        1. 이런 유연함은 프레임워크를 만드는 근간이 된다. ex.) 대표적인 에로 JDBC가 있다.
1. 단점
    1. 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
        1. 상속을 하려면 public or protected 생성자가 필요하기 때문에.
    1. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

## 아이템 5
### 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
1. 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않음.
1. 대신 클래스가 여러 자원 인스턴스를 지원해야 함 / 클라이언트가 원하는 자원을 사용해야 함.
1. 이 조건을 만족하는 간단한 패턴이, 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식.
1. 이 패턴의 변형된 것이 팩터리 메서드 패턴이다. (Supplier<T> 인터페이스가 팩터리를 표현한 완벽한 예.)

클래스 내부가 하나 이상의 자원에 의존, 그 자원이 클래스 동작에 영향을 준다면 싱글턴, 정적 유틸리티 클래스는 지양

## 아이템 26 
### 로 타입은 사용하지 말라
클래스와 인터페이스 선언에 타입 파라미터가 쓰이면, 제네릭 클래스 or 제네릭 인터페이스라 한다.

제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입 이라 한다.

1. ex.) List<String> 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다.
1. 제네릭 타입을 하나 정의하면 그에 딸린 로(raw) 타입도 함께 정의된다.
1. 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. 
	1. ex.) List<E> 의 로 타입은 List.
1. 로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안됨.
1. 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐.

TODO 뭔가 이상함 아이템 26 다시 정리하기

## 아이템 27
### 비검사 경고를 제거하라
1. 경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있다면 @SuppressWarnings("unchecked")
    1. 단, 타입 안전함을 검증한 뒤에.
1. @SuppressWarnings은 가능한 한 좁은 범위에 적용.
1. 심각한 경고를 놓칠 수 있으니 클래스 전체 적용X.
1. 한 줄 이상의 생성자 or 메소드의 @Suppress...는 지역변수 선언 쪽으로 이동. (새로 생성할 지라도)
1. 경고를 무시해도 안전한 이유를 항상 주석으로 남기기.

## 아이템 28
### 배열보다는 리스트를 사용하라
1. 배열은 공변(covariant, 함께 변한다는 뜻)
	1. Sub가 Super의 하위 타입이라면, Sub[]는 Super[]의 하위타입이 된다.
1. 제네릭은 불공변
	1. Type1, Type2가 있을 때, List<Type1>는 List<Type2> 와 관계가 없다.
	1. Object 타입으로 배열을 선언하고 Long형으로 객체를 생성한 후, 문자열을 넣어주면 컴파일에 성공하고, 런타임시에야 에러를 발견할 수 있다.
	1. 반면, 제네릭을 사용하여 Object타입의 List를 선언하고, Long타입의 ArrayList객체를 생성해준 후 문자열을 넣어주면 컴파일이 되지 않는다. 컴파일 시에 버그를 찾을 수 있다.
1. 배열은 실체화(reify)된다
	1. 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다.
	1. 위의 예제처럼 Long배열에 String을 넣으려고 하면 배열은 에러를 뱉는다.
	1. 제네릭은 런타임시에는 타입정보가 소거된다. 원소타입을 컴파일시에만 검사한다.
	1. 타입안전하지 않기 때문에 제네릭 배열을 생성하는 것은 막아져 있다.
	
배열과 리스트를 섞어 쓰다가 컴파일 오류나 경고를 만나면 가장 먼저 배열을 리스트로 만드는 방법을 고려하라
