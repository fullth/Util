## 아이템 1

### 생성자 대신 정적 팩터리 메서드를 고려하라

1. 클래스의 인스턴스를 얻는 정통적인 수단은 public 생성자. But, 클래스는 별도로 정적 팩터리 메서드를 제공할 수 있음.
2. 장점
    1. 이름을 가질 수 있다.
        1. 객체가 가지는 특성을 쉽게 묘사할 수 있다.
        ex.) BigInteger(int, int, Random), BigInteger.probabalePrime
        2. 시그니처가 같은 생성자를 여러 개 만드는데 제약이 없다.
        생성자를 정적 팩터리 메소드로 변경 후 각 차이를 잘 드러내도록 명명해주면 된다.
    2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
        1. 불필요한 객체 생성을 피할 수 있다.
        Boolean.valueOf(boolean) 메서드는 객체를 아예 생성하지 않는다. ⇒ 성능을 끌어올려 준다.
    3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. 
    4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
        1. 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.
    5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
        1. 이런 유연함은 프레임워크를 만드는 근간이 된다. ex.) 대표적인 에로 JDBC가 있다.
3. 단점
    1. 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
        1. 상속을 하려면 public or protected 생성자가 필요하기 때문에.
    2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

## 아이템 26

### 로 타입은 사용하지 말라

클래스와 인터페이스 선언에 타입 파라미터가 쓰이면, 제네릭 클래스 or 제네릭 인터페이스라 한다.

제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입 이라 한다.

1. ex.) List<String> 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다. 
2. 제네릭 타입을 하나 정의하면 그에 딸린 로(raw) 타입도 함께 정의된다.
제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. ex.) List<E> 의 로 타입은 List.
3. 컴파일러에 명확히 전달한 것에서 List와 List<Object>는 완전히 다르다.
    1. ex.) 매개변수로 List를 받는 메서드
    List<String>은 넘길 수 있음. But, List<Object>는 넘길 수 없음.
    제네릭의 하위 타입 규칙 때문. 
    즉 List<String>은 Law type List의 하위 타입 / List<Object>의 하위타입은 아님. 
4. 로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안됨.
5. 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐.

## 아이템 1

### 생성자 대신 정적 팩터리 메서드를 고려하라

1. 클래스의 인스턴스를 얻는 정통적인 수단은 public 생성자. But, 클래스는 별도로 정적 팩터리 메서드를 제공할 수 있음.
2. 장점
    1. 이름을 가질 수 있다.
        1. 객체가 가지는 특성을 쉽게 묘사할 수 있다.
        ex.) BigInteger(int, int, Random), BigInteger.probabalePrime
        2. 시그니처가 같은 생성자를 여러 개 만드는데 제약이 없다.
        생성자를 정적 팩터리 메소드로 변경 후 각 차이를 잘 드러내도록 명명해주면 된다.
    2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
        1. 불필요한 객체 생성을 피할 수 있다.
        Boolean.valueOf(boolean) 메서드는 객체를 아예 생성하지 않는다. ⇒ 성능을 끌어올려 준다.
    3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
    4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
        1. 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.
    5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
        1. 이런 유연함은 프레임워크를 만드는 근간이 된다. ex.) 대표적인 에로 JDBC가 있다.
3. 단점
    1. 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
        1. 상속을 하려면 public or protected 생성자가 필요하기 때문에.
    2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

## 아이템 5

### 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

1. 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않음.
2. 대신 클래스가 여러 자원 인스턴스를 지원해야 함 / 클라이언트가 원하는 자원을 사용해야 함.
3. 이 조건을 만족하는 간단한 패턴이, 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식.
4. 이 패턴의 변형된 것이 팩터리 메서드 패턴이다. (Supplier<T> 인터페이스가 팩터리를 표현한 완벽한 예.)

클래스 내부가 하나 이상의 자원에 의존, 그 자원이 클래스 동작에 영향을 준다면 싱글턴, 정적 유틸리티 클래스는 지양

## 아이템 26

### 로 타입은 사용하지 말라

클래스와 인터페이스 선언에 타입 파라미터가 쓰이면, 제네릭 클래스 or 제네릭 인터페이스라 한다.

제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입 이라 한다.

1. ex.) List<String> 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다.
2. 제네릭 타입을 하나 정의하면 그에 딸린 로(raw) 타입도 함께 정의된다.
제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. ex.) List<E> 의 로 타입은 List.
3. 컴파일러에 명확히 전달한 것에서 List와 List<Object>는 완전히 다르다.
    1. ex.) 매개변수로 List를 받는 메서드
    List<String>은 넘길 수 있음. But, List<Object>는 넘길 수 없음.
    제네릭의 하위 타입 규칙 때문.
    즉 List<String>은 Law type List의 하위 타입 / List<Object>의 하위타입은 아님.
4. 로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안됨.
5. 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐.

## 아이템 27

### 생성자 대신 정적 팩터리 메서드를 고려하라

1. 클래스의 인스턴스를 얻는 정통적인 수단은 public 생성자. But, 클래스는 별도로 정적 팩터리 메서드를 제공할 수 있음.
2. 장점
    1. 이름을 가질 수 있다.
        1. 객체가 가지는 특성을 쉽게 묘사할 수 있다.
        ex.) BigInteger(int, int, Random), BigInteger.probabalePrime
        2. 시그니처가 같은 생성자를 여러 개 만드는데 제약이 없다.
        생성자를 정적 팩터리 메소드로 변경 후 각 차이를 잘 드러내도록 명명해주면 된다.
    2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
        1. 불필요한 객체 생성을 피할 수 있다.
        Boolean.valueOf(boolean) 메서드는 객체를 아예 생성하지 않는다. ⇒ 성능을 끌어올려 준다.
    3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
    4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
        1. 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.
    5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
        1. 이런 유연함은 프레임워크를 만드는 근간이 된다. ex.) 대표적인 에로 JDBC가 있다.
3. 단점
    1. 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
        1. 상속을 하려면 public or protected 생성자가 필요하기 때문에.
    2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

## 아이템 26

### 로 타입은 사용하지 말라

클래스와 인터페이스 선언에 타입 파라미터가 쓰이면, 제네릭 클래스 or 제네릭 인터페이스라 한다.

제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입 이라 한다.

1. ex.) List<String> 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다.
2. 제네릭 타입을 하나 정의하면 그에 딸린 로(raw) 타입도 함께 정의된다.
제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. ex.) List<E> 의 로 타입은 List.
3. 컴파일러에 명확히 전달한 것에서 List와 List<Object>는 완전히 다르다.
    1. ex.) 매개변수로 List를 받는 메서드
    List<String>은 넘길 수 있음. But, List<Object>는 넘길 수 없음.
    제네릭의 하위 타입 규칙 때문.
    즉 List<String>은 Law type List의 하위 타입 / List<Object>의 하위타입은 아님.
4. 로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안됨.
5. 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐.

## 아이템 1

### 생성자 대신 정적 팩터리 메서드를 고려하라

1. 클래스의 인스턴스를 얻는 정통적인 수단은 public 생성자. But, 클래스는 별도로 정적 팩터리 메서드를 제공할 수 있음.
2. 장점
    1. 이름을 가질 수 있다.
        1. 객체가 가지는 특성을 쉽게 묘사할 수 있다.
        ex.) BigInteger(int, int, Random), BigInteger.probabalePrime
        2. 시그니처가 같은 생성자를 여러 개 만드는데 제약이 없다.
        생성자를 정적 팩터리 메소드로 변경 후 각 차이를 잘 드러내도록 명명해주면 된다.
    2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
        1. 불필요한 객체 생성을 피할 수 있다.
        Boolean.valueOf(boolean) 메서드는 객체를 아예 생성하지 않는다. ⇒ 성능을 끌어올려 준다.
    3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
    4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
        1. 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.
    5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
        1. 이런 유연함은 프레임워크를 만드는 근간이 된다. ex.) 대표적인 에로 JDBC가 있다.
3. 단점
    1. 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
        1. 상속을 하려면 public or protected 생성자가 필요하기 때문에.
    2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

## 아이템 5

### 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

1. 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않음.
2. 대신 클래스가 여러 자원 인스턴스를 지원해야 함 / 클라이언트가 원하는 자원을 사용해야 함.
3. 이 조건을 만족하는 간단한 패턴이, 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식.
4. 이 패턴의 변형된 것이 팩터리 메서드 패턴이다. (Supplier<T> 인터페이스가 팩터리를 표현한 완벽한 예.)

클래스 내부가 하나 이상의 자원에 의존, 그 자원이 클래스 동작에 영향을 준다면 싱글턴, 정적 유틸리티 클래스는 지양

## 아이템 26

### 로 타입은 사용하지 말라

클래스와 인터페이스 선언에 타입 파라미터가 쓰이면, 제네릭 클래스 or 제네릭 인터페이스라 한다.

제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입 이라 한다.

1. ex.) List<String> 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다.
2. 제네릭 타입을 하나 정의하면 그에 딸린 로(raw) 타입도 함께 정의된다.
제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. ex.) List<E> 의 로 타입은 List.
3. 컴파일러에 명확히 전달한 것에서 List와 List<Object>는 완전히 다르다.
    1. ex.) 매개변수로 List를 받는 메서드
    List<String>은 넘길 수 있음. But, List<Object>는 넘길 수 없음.
    제네릭의 하위 타입 규칙 때문.
    즉 List<String>은 Law type List의 하위 타입 / List<Object>의 하위타입은 아님.
4. 로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안됨.
5. 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐.

## 아이템 27

### 비검사 경고를 제거하라

1. 경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있다면 @SuppressWarnings("unchecked")
2. 단, 타입 안전함을 검증한 뒤에.
3. @SuppressWarnings은 가능한 한 좁은 범위에 적용.
4. 심각한 경고를 놓칠 수 있으니 클래스 전체 적용X.
5. 한 줄 이상의 생성자 or 메소드의 @Suppress...는 지역변수 선언 쪽으로 이동. (새로 생성할 지라도)
6. 경고를 무시해도 안전한 이유를 항상 주석으로 남기기.

### 비검사 경고를 제거하라

경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있다면 @SuppressWarnings("unchecked")
단, 타입 안전함을 검증한 뒤에.
@SuppressWarnings은 가능한 한 좁은 범위에 적용. 심각한 경고를 놓칠 수 있으니 클래스 전체 적용X.
한 줄 이상의 생성자 or 메소드의 @Suppress...는 지역변수 선언 쪽으로 이동. (새로 생성할 지라도)
경고를 무시해도 안전한 이유를 항상 주석으로 남기기.

### 생성자 대신 정적 팩터리 메서드를 고려하라

1. 클래스의 인스턴스를 얻는 정통적인 수단은 public 생성자. But, 클래스는 별도로 정적 팩터리 메서드를 제공할 수 있음.
2. 장점
    1. 이름을 가질 수 있다.
        1. 객체가 가지는 특성을 쉽게 묘사할 수 있다.
        ex.) BigInteger(int, int, Random), BigInteger.probabalePrime
        2. 시그니처가 같은 생성자를 여러 개 만드는데 제약이 없다.
        생성자를 정적 팩터리 메소드로 변경 후 각 차이를 잘 드러내도록 명명해주면 된다.
    2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
        1. 불필요한 객체 생성을 피할 수 있다.
        Boolean.valueOf(boolean) 메서드는 객체를 아예 생성하지 않는다. ⇒ 성능을 끌어올려 준다.
    3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
    4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
        1. 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.
    5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
        1. 이런 유연함은 프레임워크를 만드는 근간이 된다. ex.) 대표적인 에로 JDBC가 있다.
3. 단점
    1. 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
        1. 상속을 하려면 public or protected 생성자가 필요하기 때문에.
    2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

## 아이템 26

### 로 타입은 사용하지 말라

클래스와 인터페이스 선언에 타입 파라미터가 쓰이면, 제네릭 클래스 or 제네릭 인터페이스라 한다.

제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입 이라 한다.

1. ex.) List<String> 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다.
2. 제네릭 타입을 하나 정의하면 그에 딸린 로(raw) 타입도 함께 정의된다.
제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. ex.) List<E> 의 로 타입은 List.
3. 컴파일러에 명확히 전달한 것에서 List와 List<Object>는 완전히 다르다.
    1. ex.) 매개변수로 List를 받는 메서드
    List<String>은 넘길 수 있음. But, List<Object>는 넘길 수 없음.
    제네릭의 하위 타입 규칙 때문.
    즉 List<String>은 Law type List의 하위 타입 / List<Object>의 하위타입은 아님.
4. 로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안됨.
5. 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐.

## 아이템 1

### 생성자 대신 정적 팩터리 메서드를 고려하라

1. 클래스의 인스턴스를 얻는 정통적인 수단은 public 생성자. But, 클래스는 별도로 정적 팩터리 메서드를 제공할 수 있음.
2. 장점
    1. 이름을 가질 수 있다.
        1. 객체가 가지는 특성을 쉽게 묘사할 수 있다.
        ex.) BigInteger(int, int, Random), BigInteger.probabalePrime
        2. 시그니처가 같은 생성자를 여러 개 만드는데 제약이 없다.
        생성자를 정적 팩터리 메소드로 변경 후 각 차이를 잘 드러내도록 명명해주면 된다.
    2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
        1. 불필요한 객체 생성을 피할 수 있다.
        Boolean.valueOf(boolean) 메서드는 객체를 아예 생성하지 않는다. ⇒ 성능을 끌어올려 준다.
    3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
    4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
        1. 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.
    5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
        1. 이런 유연함은 프레임워크를 만드는 근간이 된다. ex.) 대표적인 에로 JDBC가 있다.
3. 단점
    1. 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
        1. 상속을 하려면 public or protected 생성자가 필요하기 때문에.
    2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

## 아이템 5

### 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

1. 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않음.
2. 대신 클래스가 여러 자원 인스턴스를 지원해야 함 / 클라이언트가 원하는 자원을 사용해야 함.
3. 이 조건을 만족하는 간단한 패턴이, 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식.
4. 이 패턴의 변형된 것이 팩터리 메서드 패턴이다. (Supplier<T> 인터페이스가 팩터리를 표현한 완벽한 예.)

클래스 내부가 하나 이상의 자원에 의존, 그 자원이 클래스 동작에 영향을 준다면 싱글턴, 정적 유틸리티 클래스는 지양

## 아이템 26

### 로 타입은 사용하지 말라

클래스와 인터페이스 선언에 타입 파라미터가 쓰이면, 제네릭 클래스 or 제네릭 인터페이스라 한다.

제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입 이라 한다.

1. ex.) List<String> 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다.
2. 제네릭 타입을 하나 정의하면 그에 딸린 로(raw) 타입도 함께 정의된다.
제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. ex.) List<E> 의 로 타입은 List.
3. 컴파일러에 명확히 전달한 것에서 List와 List<Object>는 완전히 다르다.
    1. ex.) 매개변수로 List를 받는 메서드
    List<String>은 넘길 수 있음. But, List<Object>는 넘길 수 없음.
    제네릭의 하위 타입 규칙 때문.
    즉 List<String>은 Law type List의 하위 타입 / List<Object>의 하위타입은 아님.
4. 로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안됨.
5. 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐.

## 아이템 27

### 비검사 경고를 제거하라

1. 경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있다면 @SuppressWarnings("unchecked")
    1. 단, 타입 안전함을 검증한 뒤에.
2. @SuppressWarnings은 가능한 한 좁은 범위에 적용.
3. 심각한 경고를 놓칠 수 있으니 클래스 전체 적용X.
4. 한 줄 이상의 생성자 or 메소드의 @Suppress...는 지역변수 선언 쪽으로 이동. (새로 생성할 지라도)
5. 경고를 무시해도 안전한 이유를 항상 주석으로 남기기.
